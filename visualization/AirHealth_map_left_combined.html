<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>US Choropleth â€” AirHealth</title>
  <script src="./lib/d3.v5.min.js"></script>
  <style>
    :root {
      --bg: #f8fafc;
      --ink: #0f172a;
      --muted: #64748b;
      --card: #ffffff;
      --accent: #2563eb;
      --border: #e5e7eb;
    }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans', Ubuntu, Cantarell, 'Helvetica Neue', Arial;
      color: var(--ink);
      background: radial-gradient(1200px 600px at 30% 0%, #eef2ff 0%, var(--bg) 40%);
    }
    .wrap { max-width: 1200px; margin: 24px auto 40px; padding: 0 16px; }
    h1 { margin: 0 0 10px; font-size: 20px; font-weight: 700; letter-spacing: 0.2px; }
    .toolbar { display: grid; grid-template-columns: auto auto 1fr; gap: 16px; align-items: center; }
    .controls { display: flex; gap: 12px; align-items: center; }
    .select { position: relative; }
    select {
      appearance: none; -webkit-appearance: none; -moz-appearance: none;
      border: 1px solid var(--border); background: var(--card);
      border-radius: 12px; padding: 10px 40px 10px 14px; font-size: 14px; color: var(--ink);
      box-shadow: 0 1px 1px rgba(16,24,40,.04), 0 1px 2px rgba(16,24,40,.06);
      outline: none;
    }
    .select:after {
      content: '\25BE';
      position: absolute; right: 12px; top: 50%; transform: translateY(-50%);
      color: var(--muted); pointer-events: none; font-size: 14px;
    }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 14px;
    }
    .layout { display: grid; grid-template-columns: 2fr 1fr; gap: 16px; margin-top: 14px; }
    .mapPanel { position: relative; }

    svg { width: 100%; height: auto; display: block; }
    .state { fill: #e5edf5; stroke: #ffffff; stroke-width: 1; cursor: pointer; }
    .state:hover { filter: brightness(0.95); }
    .abbr {
      font: 11px/1.1 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto;
      fill: #0f172a;
      text-anchor: middle;
      pointer-events: none;
    }

    /* Slider */
    .sliderWrap {
      padding: 10px 14px 10px 10px;
      grid-column: 1 / -1;
      height: 70px;
      display: flex;
      flex-direction: column;
    }
    .sliderTitle { font-size: 14px; margin-bottom: 8px; font-weight: 600; letter-spacing: .02em; }
    .slider svg { width: 100%; height: 70px; }
    .track { stroke: #e2e8f0; stroke-linecap: round; stroke-width: 6; }
    .track-inset { stroke: #f8fafc; stroke-width: 4; }
    .track-overlay { pointer-events: stroke; stroke-width: 36; cursor: ew-resize; opacity: 0; }
    .handle { fill: var(--card); stroke: var(--accent); stroke-width: 2.5; }
    .tick text { font-size: 11px; fill: var(--muted); transform: translateY(-10px); }

    .pop {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 10;
      pointer-events: none;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: 0 8px 24px rgba(15, 23, 42, .14);
      padding: 10px 10px 8px;
      min-width: 220px;
      max-width: 260px;
      transform: translate(-50%, -100%);
      display: none;
    }

    .pop .title {
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 4px;
    }

    .pop .sub {
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 6px;
    }

    .pop .legend {
      font-size: 11px;
      color: var(--muted);
      display: flex;
      gap: 10px;
      margin-bottom: 6px;
    }

    .pop .legend i {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 2px;
      margin-right: 6px;
    }

    .pop .legend .a { background: #93c5fd; } /* light blue */
    .pop .legend .c { background: #facc15; } /* amber */
    .pop .legend .i { background: #f9a8d4; } /* pink */

    .bar.asthma { fill: #93c5fd; }
    .bar.copd { fill: #facc15; }
    .bar.ihd { fill: #f9a8d4; }

    .axis text { font-size: 10px; fill: var(--muted); }
    .axis path, .axis line { stroke: #e5e7eb; }

    #lineChartPanel {
      margin-bottom: 60px; /* space under the line chart card */
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>AirHealth â€” US Choropleth</h1>
    <div class="toolbar">
      <div class="controls">
        <div class="select">
          <select id="pollutant">
            <option value="" selected disabled>Pollutants</option>
            <option value="pm25">PMâ‚‚.â‚… (Fine Particulate)</option>
            <option value="o3">Oâ‚ƒ (Ozone)</option>
            <option value="no2">NOâ‚‚ (Nitrogen Dioxide)</option>
          </select>
        </div>
        <div class="select">
          <select id="year">
            <option value="" selected disabled>Year</option>
          </select>
        </div>
      </div>
      <div class="card sliderWrap">
        <div class="sliderTitle">Month</div>
        <div id="month-slider" class="slider"></div>
      </div>
    </div>

    <div class="layout">
      <div class="card mapPanel">
        <svg id="map" viewBox="0 0 960 600" aria-label="US States map"></svg>

        <!-- Tooltip popover for state mortality -->
        <div id="pop" class="pop" role="tooltip" aria-live="polite">
          <div class="title" id="pop-title"></div>
          <div class="sub" id="pop-sub"></div>

          <!-- Disease color legend: always visible -->
          <div class="legend" id="disease-legend">
            <span><i class="a"></i>Asthma</span>
            <span><i class="c"></i>COPD</span>
            <span><i class="i"></i>IHD</span>
          </div>

          <!-- Selected pollutant info (value + unit) -->
          <div id="pollutant-info" style="font-size:11px; color:var(--muted); margin-top:2px; margin-bottom:4px;"></div>

          <svg id="pop-chart" width="240" height="150" aria-label="Mortality mini chart"></svg>
        </div>

        <!-- Color scale legend for pollutants - positioned below map -->
        <div id="color-legend"
             style="margin-top: 14px; background: var(--card); border: 1px solid var(--border);
                    border-radius: 12px; padding: 10px 14px; display: none; pointer-events: none;
                    width: fit-content; margin-left: auto; margin-right: 0;">
          <div id="legend-title"
               style="font-size: 11px; font-weight: 600; margin-bottom: 6px; color: var(--muted);">
            PMâ‚‚.â‚… (Î¼g/mÂ³)
          </div>
          <svg id="legend-gradient" width="180" height="12" style="margin-bottom: 4px;"></svg>
          <div style="display: flex; justify-content: space-between; font-size: 10px; color: var(--muted);">
            <span id="legend-min">0</span>
            <span id="legend-max">15</span>
          </div>
        </div>
      </div>
    </div>

    <div class="layout">
      <div class="card" id="lineChartPanel">
        <div class="select" style="margin-bottom:12px; width:180px;">
          <select id="state">
            <option value="" selected disabled>State</option>
          </select>
        </div>
        <svg id="lineChart" width="700" height="380"></svg>
      </div>
    </div>
  </div>

<script>
(function() {
  // --- Year dropdown ---
  var years = d3.range(2018, 2026);
  var yearSel = d3.select('#year');
  yearSel.selectAll('option.yr')
    .data(years)
    .enter().append('option')
    .attr('class','yr')
    .attr('value', String)
    .text(String);

  // --- Slider setup ---
  var months = ['JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG','SEP','OCT','NOV','DEC'];
  var sliderSVG, gS, x, handle, activeMonth;

  function drawSlider() {
    d3.select('#month-slider').selectAll('svg').remove();

    var mapW = document.querySelector('.mapPanel').getBoundingClientRect().width;
    var sliderW = Math.max(300, Math.floor(mapW));
    var sliderH = 60;
    var margin = {left: 24, right: 30, top: 16, bottom: 16};
    var innerW = sliderW - margin.left - margin.right;

    sliderSVG = d3.select('#month-slider').append('svg')
      .attr('width', sliderW)
      .attr('height', sliderH);

    gS = sliderSVG.append('g').attr('transform', 'translate(' + margin.left + ',30)');

    x = d3.scalePoint().domain(months).range([0, innerW]).padding(0.5);
    var xIdx = d3.scaleLinear().domain([0, months.length - 1]).range([0, innerW]).clamp(true);

    function clampPx(px) { return Math.max(x.range()[0], Math.min(x.range()[1], px)); }

    function smoothDrag(pxAbs) {
      var local = clampPx(pxAbs - margin.left);
      var idx = xIdx.invert(local);
      handle.attr('cx', xIdx(idx));
    }

    function snapToNearest(pxAbs) {
      var local = clampPx(pxAbs - margin.left);
      var idx = xIdx.invert(local);
      var i = Math.round(idx);
      i = Math.max(0, Math.min(months.length - 1, i));
      activeMonth = months[i];
      handle.attr('cx', x(activeMonth));
      var detail = { month: activeMonth, index: i };
      var ev = new CustomEvent('monthchange', { detail: detail });
      document.body.dispatchEvent(ev);
    }

    gS.append('line').attr('class','track')
      .attr('x1', x.range()[0]).attr('x2', x.range()[1])
      .attr('y1',0).attr('y2',0);
    gS.append('line').attr('class','track-inset')
      .attr('x1', x.range()[0]).attr('x2', x.range()[1])
      .attr('y1',0).attr('y2',0);

    var overlay = gS.append('line').attr('class','track-overlay')
      .attr('x1', x.range()[0]).attr('x2', x.range()[1])
      .attr('y1',0).attr('y2',0);
    overlay.call(d3.drag()
      .on('start drag', function() { smoothDrag(d3.event.x); })
      .on('end', function() { snapToNearest(d3.event.x); })
    );

    gS.append('g').attr('class','axis axis--x')
      .call(d3.axisBottom(x).tickSize(0))
      .selectAll('text').attr('dy', -10);

    var initialIdx = 0;
    activeMonth = months[initialIdx];
    handle = gS.append('circle')
      .attr('class','handle').attr('r', 10)
      .attr('cy', 0).attr('cx', x(activeMonth));

    handle.call(d3.drag()
      .on('start drag', function() { smoothDrag(d3.event.x); })
      .on('end', function() { snapToNearest(d3.event.x); })
    );
  }

  function alignSliderBox() {
    var wrap = document.querySelector('.wrap');
    var map = document.querySelector('.mapPanel');
    var sliderBox = document.querySelector('.sliderWrap');
    if (!wrap || !map || !sliderBox) return;
    var wrapRect = wrap.getBoundingClientRect();
    var mapRect = map.getBoundingClientRect();
    sliderBox.style.width = (mapRect.width - 30) + 'px';
    sliderBox.style.marginLeft = (mapRect.left - wrapRect.left - 16) + 'px';
  }

  function reflowSlider() { alignSliderBox(); drawSlider(); }

  reflowSlider();
  window.addEventListener('resize', reflowSlider);

  // Listen for month changes
  document.body.addEventListener('monthchange', function(e){
    console.log('[Month changed]', e.detail);
    updateMapColors();
  });

  // --- Map rendering ---
  var mapSvg = d3.select('#map');
  var gMap = mapSvg.append('g');

  var projection = d3.geoAlbersUsa().translate([480, 300]).scale(1150);
  var path = d3.geoPath().projection(projection);

  d3.json('./data/us-states.json').then(function(geo) {
    var states = geo.features;

    gMap.selectAll('path.state')
      .data(states)
      .enter().append('path')
      .attr('class', 'state')
      .attr('d', path);

    gMap.selectAll('text.abbr')
      .data(states)
      .enter().append('text')
      .attr('class','abbr')
      .attr('transform', function(d){
        var c = path.centroid(d);
        return 'translate(' + (isFinite(c[0]) ? c[0] : -9999) + ',' + (isFinite(c[1]) ? c[1] : -9999) + ')';
      })
      .attr('dy', 3)
      .text(function(d){ return d.id || ''; });
  }).catch(function(err){
    console.error('Failed to load GeoJSON. Make sure ./data/us-states.json exists.', err);
  });

  // --- Tooltip Popover setup ---
  var pop = document.getElementById('pop');
  var popTitle = document.getElementById('pop-title');
  var popSub = document.getElementById('pop-sub');
  var popSvg = d3.select('#pop-chart');

  function showPop() { pop.style.display = 'block'; }
  function hidePop() { pop.style.display = 'none'; }
  function movePop(evt) {
    const panel = document.querySelector('.mapPanel').getBoundingClientRect();
    const popRect = pop.getBoundingClientRect();
    const x = evt.clientX - panel.left + 14;
    const y = evt.clientY - panel.top - 10;
    const left = Math.min(Math.max(8, x), panel.width - popRect.width - 8);
    const top = Math.min(Math.max(8, y), panel.height - popRect.height - 8);
    pop.style.left = left + 'px';
    pop.style.top = top + 'px';
  }

  // --- Pollutant data storage ---
  // Structure: pollutantData[pollutant][monthCode] = Map(stateName -> value)
  var pollutantData = {
    pm25: new Map(),
    no2: new Map(),
    o3: new Map()
  };

  // Structure: yearRanges[pollutant][year] = {min: number, max: number}
  var yearRanges = {
    pm25: new Map(),
    no2: new Map(),
    o3: new Map()
  };

  // Convert "2018-01" -> "2018/01"
  function convertMonthFormat(monthStr) {
    return monthStr.replace('-', '/');
  }

  // Get year from month code "YYYY/MM" -> "YYYY"
  function getYearFromMonthCode(monthCode) {
    return monthCode.split('/')[0];
  }

  // Load pollutant data
  function loadPollutantData(label, csvPath, pollutantKey) {
    return d3.csv(csvPath).then(function(data) {
      console.log('[' + label + ' data] Loaded', data.length, 'rows');

      var valuesByYear = new Map();

      data.forEach(function(d) {
        var monthCode = convertMonthFormat(d.Month);
        var year = getYearFromMonthCode(monthCode);
        var value = +d['Arithmetic Mean'] || 0;

        if (!pollutantData[pollutantKey].has(monthCode)) {
          pollutantData[pollutantKey].set(monthCode, new Map());
        }
        var monthMap = pollutantData[pollutantKey].get(monthCode);
        monthMap.set(d['State Name'], value);

        if (!valuesByYear.has(year)) {
          valuesByYear.set(year, []);
        }
        valuesByYear.get(year).push(value);
      });

      valuesByYear.forEach(function(values, year) {
        var min = d3.min(values);
        var max = d3.max(values);
        yearRanges[pollutantKey].set(year, {min: min, max: max});
        console.log('[' + label + ' year range]', year, 'Min:', min.toFixed(2), 'Max:', max.toFixed(2));
      });

      console.log('[' + label + ' data loaded]', pollutantData[pollutantKey].size, 'months');
      console.log('[' + label + ' sample keys]', Array.from(pollutantData[pollutantKey].keys()).slice(0, 10));

      // If pollutant/year already selected, recolor
      updateMapColors();
    }).catch(function(err) {
      console.error('Failed to load ' + label + ' data:', err);
    });
  }

  // Load pollutants
  loadPollutantData('PM2.5', './data/PM2.5_state_month_2018_2025.csv', 'pm25');
  loadPollutantData('NO2', './data/no2_state_month_2018_2025.csv', 'no2');
  loadPollutantData('O3', './data/ozone_state_month_2018_2025.csv', 'o3');

  // Color scale for pollutants
  var pollutantColorScale = d3.scaleSequential(d3.interpolateYlOrRd)
    .domain([0, 15]); // will be updated based on selected year

  // Update legend gradient
  function updateLegendGradient(min, max) {
    var legendGradient = d3.select('#legend-gradient');
    legendGradient.selectAll('*').remove();

    var defs = legendGradient.append('defs');
    var gradient = defs.append('linearGradient')
      .attr('id', 'pollutant-gradient')
      .attr('x1', '0%')
      .attr('x2', '100%');

    var numStops = 10;
    for (var i = 0; i <= numStops; i++) {
      var value = min + (i / numStops) * (max - min);
      gradient.append('stop')
        .attr('offset', (i / numStops * 100) + '%')
        .attr('stop-color', pollutantColorScale(value));
    }

    legendGradient.append('rect')
      .attr('width', 180)
      .attr('height', 12)
      .attr('fill', 'url(#pollutant-gradient)')
      .attr('rx', 2);
  }

  // helper used by multiple parts
  function keyFor(year, monthIdx) {
    var mm = String(monthIdx + 1).padStart(2, '0');
    return year + '/' + mm;
  }

  // Update map colors
  function updateMapColors() {
    var selectedPollutant = d3.select('#pollutant').property('value');
    var selectedYear = d3.select('#year').property('value');

    if (!selectedPollutant || !selectedYear) {
      gMap.selectAll('path.state').style('fill', '#e5edf5');
      d3.select('#color-legend').style('display', 'none');
      return;
    }

    var pollutantConfig = {
      pm25: { name: 'PMâ‚‚.â‚…', unit: 'Î¼g/mÂ³', dataKey: 'pm25' },
      no2: { name: 'NOâ‚‚', unit: 'ppb', dataKey: 'no2' },
      o3:  { name: 'Oâ‚ƒ',  unit: 'ppb', dataKey: 'o3' }
    };

    var config = pollutantConfig[selectedPollutant];
    if (!config) {
      gMap.selectAll('path.state').style('fill', '#e5edf5');
      d3.select('#color-legend').style('display', 'none');
      return;
    }

    var yearRange = yearRanges[config.dataKey].get(selectedYear);
    if (!yearRange) {
      console.warn('No year range for', selectedPollutant, selectedYear);
      gMap.selectAll('path.state').style('fill', '#e5edf5');
      d3.select('#color-legend').style('display', 'none');
      return;
    }

    pollutantColorScale.domain([yearRange.min, yearRange.max]);

    d3.select('#legend-title').text(config.name + ' (' + config.unit + ')');
    d3.select('#legend-min').text(yearRange.min.toFixed(2));
    d3.select('#legend-max').text(yearRange.max.toFixed(2));
    updateLegendGradient(yearRange.min, yearRange.max);

    d3.select('#color-legend').style('display', 'block');

    var monthIdx = activeMonth ? months.indexOf(activeMonth) : 0;
    var monthCode = keyFor(selectedYear, monthIdx);

    console.log('[updateMapColors]', config.name, 'selected, monthCode:', monthCode,
                'Range:', yearRange.min, '-', yearRange.max);

    var monthData = pollutantData[config.dataKey].get(monthCode);
    if (!monthData) {
      console.warn('No', config.name, 'data for', monthCode, '- Available keys:',
        Array.from(pollutantData[config.dataKey].keys()).slice(0, 5));
      gMap.selectAll('path.state').style('fill', '#e5edf5');
      d3.select('#color-legend').style('display', 'none');
      return;
    }

    console.log('[updateMapColors] Found data for', monthCode, '- States:', monthData.size);

    var statePaths = gMap.selectAll('path.state');
    console.log('[updateMapColors] Found', statePaths.size(), 'state paths');

    statePaths.style('fill', function(d) {
      var stateName = d.properties.name;
      var value = monthData.get(stateName);
      if (value === undefined || isNaN(value)) {
        return '#e5edf5';
      }
      return pollutantColorScale(value);
    });
  }

  // ðŸ”¸ ì—¬ê¸°ì„œ pollutant/year ë°”ë€” ë•Œë§ˆë‹¤ ì§€ë„ ì—…ë°ì´íŠ¸
  d3.select('#pollutant').on('change', function(){
    console.log('[Pollutant]', this.value);
    updateMapColors();
  });

  d3.select('#year').on('change', function(){
    console.log('[Year]', +this.value);
    updateMapColors();
  });

  // --- Mortality Line Chart (yearly, normalized) ---
  var svgLine = d3.select("#lineChart"),
      margin = {top: 40, right: 70, bottom: 50, left: 100},
      width = +svgLine.attr("width") - margin.left - margin.right,
      height = +svgLine.attr("height") - margin.top - margin.bottom;

  var gLine = svgLine.append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

  var xLine = d3.scaleTime().range([0, width]);
  var yLine = d3.scaleLinear().range([height, 0]);

  var color = d3.scaleOrdinal()
    .domain(["Asthma", "COPD", "IHD"])
    .range([
      "rgba(147,197,253,0.8)",  // Asthma
      "rgba(250,204,21,0.8)",   // COPD
      "rgba(249,168,212,0.8)"   // IHD
    ]);

  var xAxis = d3.axisBottom(xLine)
    .ticks(d3.timeYear.every(1))
    .tickFormat(d3.timeFormat("%Y"))
    .tickPadding(8);
  var yAxis = d3.axisLeft(yLine).tickFormat(d3.format(".1f"));

  gLine.append("g").attr("class", "x-axis")
      .attr("transform", "translate(0," + height + ")");
  gLine.append("g").attr("class", "y-axis");

  gLine.append("text")
    .attr("x", width / 2)
    .attr("y", -10)
    .attr("text-anchor", "middle")
    .style("font-weight", "600")
    .text("Yearly Mortality Rate per 100,000 by Disease (2018-2024)");

  gLine.append("text")
    .attr("x", width / 2)
    .attr("y", height + 40)
    .attr("text-anchor", "middle")
    .style("fill", "#64748b")
    .text("Year");

  gLine.append("text")
    .attr("transform", "rotate(-90)")
    .attr("y", -45)
    .attr("x", -height / 2)
    .attr("text-anchor", "middle")
    .style("fill", "#64748b")
    .text("Mortality Rate per 100,000");

  // Legend for line chart
  var legend = gLine.append("g")
    .attr("class", "legend")
    .attr("transform", "translate(" + (width + 20) + ", 0)");

  var legendItems = [
    { name: "Asthma", color: "rgba(147,197,253,0.8)" },
    { name: "COPD",  color: "rgba(250,204,21,0.8)" },
    { name: "IHD",   color: "rgba(249,168,212,0.8)" }
  ];

  legend.selectAll("rect")
    .data(legendItems)
    .enter().append("rect")
    .attr("x", 0)
    .attr("y", (d, i) => i * 20)
    .attr("width", 10)
    .attr("height", 10)
    .attr("rx", 2)
    .attr("fill", d => d.color)
    .attr("fill-opacity", 0.9);

  legend.selectAll("text")
    .data(legendItems)
    .enter().append("text")
    .attr("x", 16)
    .attr("y", (d, i) => i * 20 + 9)
    .attr("text-anchor", "start")
    .style("font-size", "11.5px")
    .style("fill", "#334155")
    .text(d => d.name);

  var tooltip = d3.select("body").append("div")
    .attr("class", "tooltip")
    .style("position", "absolute")
    .style("padding", "6px 10px")
    .style("background", "#fff")
    .style("border", "1px solid #ddd")
    .style("border-radius", "6px")
    .style("font-size", "13px")
    .style("pointer-events", "none")
    .style("opacity", 0);

  // --- Mortality & population data ---
  Promise.all([
    d3.csv("./data/copd_final.csv"),
    d3.csv("./data/asthma_final.csv"),
    d3.csv("./data/ihd_final.csv"),
    d3.csv("./data/state_population.csv")
  ]).then(function([copd, asthma, ihd, pop]) {

    copd.forEach(d => d.disease = "COPD");
    asthma.forEach(d => d.disease = "Asthma");
    ihd.forEach(d => d.disease = "IHD");

    var data = copd.concat(asthma, ihd);

    var parseMonth = d3.timeParse("%Y/%m");
    var formatMonth = d3.timeFormat("%Y/%m");

    data.forEach(function(d) {
      d.date = parseMonth(String(d["Month Code"]));
      d.deaths = +d["Deaths"];
      d.state = d["Residence State"];
    });

    var popByStateYear = {};
    pop.forEach(function(d) {
      var state = d.State;
      for (var year = 2018; year <= 2024; year++) {
        var col = String(year);
        var raw = d[col];
        if (!raw) continue;
        var val = +raw.replace(/,/g, "");
        if (!isNaN(val)) {
          popByStateYear[state + "_" + year] = val;
        }
      }
    });

    var allStates = Array.from(new Set(data.map(d => d.state))).sort();
    var diseases = Array.from(new Set(data.map(d => d.disease)));

    // Full months Jan 2018 â€“ Dec 2024
    var fullMonths = [];
    for (let y = 2018; y <= 2024; y++) {
      for (let m = 1; m <= 12; m++) {
        fullMonths.push(`${y}/${String(m).padStart(2, "0")}`);
      }
    }

    // Fill missing combinations with 0 deaths
    var filledData = [];
    allStates.forEach(state => {
      diseases.forEach(disease => {
        fullMonths.forEach(monthCode => {
          const found = data.find(
            d =>
              d.state === state &&
              d.disease === disease &&
              formatMonth(d.date) === monthCode
          );
          if (found) {
            filledData.push(found);
          } else {
            filledData.push({
              state: state,
              disease: disease,
              date: parseMonth(monthCode),
              deaths: 0
            });
          }
        });
      });
    });

    data = filledData;

    // Global max mortality rate
    var GLOBAL_MAX = 0;
    allStates.forEach(state => {
      diseases.forEach(disease => {
        d3.range(2018, 2025).forEach(year => {
          let key = state + "_" + year;
          let popVal = popByStateYear[key];
          if (!popVal) return;

          let yearlyDeaths = data.filter(
            d => d.state === state &&
                 d.disease === disease &&
                 d.date.getFullYear() === year
          ).reduce((sum, d) => sum + d.deaths, 0);

          let rate = yearlyDeaths / popVal * 100000;
          if (rate > GLOBAL_MAX) GLOBAL_MAX = rate;
        });
      });
    });

    console.log("Global max mortality rate:", GLOBAL_MAX);

    // Populate state dropdown
    d3.select("#state")
      .selectAll("option.stateOpt")
      .data(allStates)
      .enter().append("option")
      .attr("value", d => d)
      .text(d => d);

    var allYears = d3.range(2018, 2025);
    xLine.domain(d3.extent(allYears, d => new Date(d, 0, 1)));
    yLine.domain([0, GLOBAL_MAX * 1.1]).nice();

    gLine.select(".x-axis")
      .call(d3.axisBottom(xLine)
        .ticks(d3.timeYear.every(1))
        .tickFormat(d3.timeFormat("%Y"))
        .tickSizeOuter(0)
        .tickPadding(10))
      .selectAll("text")
      .attr("dy", "1.5em")
      .style("fill", "#475569")
      .style("font-size", "12px");

    gLine.select(".y-axis")
      .call(yAxis);

    function updateChart(state) {
      var filtered = data.filter(d => d.state === state);

      var yearly = d3.nest()
        .key(d => d.disease)
        .key(d => {
          const year = d.date.getFullYear();
          return (year <= 2024) ? year : null;
        })
        .rollup(v => d3.sum(v, d => d.deaths))
        .entries(filtered)
        .map(g => ({
          name: g.key,
          values: g.values
            .filter(v => v.key !== "null")
            .map(v => ({ year: +v.key, deaths: v.value }))
            .sort((a, b) => a.year - b.year)
        }));

      if (yearly.length === 0) {
        console.warn("No data for state:", state);
        return;
      }

      yearly.forEach(function(series) {
        series.values.forEach(function(v) {
          var key = state + "_" + v.year;
          var pop = popByStateYear[key];
          if (pop && pop > 0) {
            v.rate = (v.deaths / pop) * 100000;
          } else {
            v.rate = null;
          }
        });

        series.values = series.values.filter(v => v.rate !== null);
      });

      yearly = yearly.filter(s => s.values.length > 0);
      if (!yearly.length) {
        console.warn("No rate data for state (population missing?):", state);
        return;
      }

      var lineGen = d3.line()
        .x(d => xLine(new Date(d.year, 0, 1)))
        .y(d => yLine(d.rate))
        .curve(d3.curveMonotoneX);

      var lines = gLine.selectAll(".disease-line")
        .data(yearly, d => d.name);

      lines.enter().append("path")
        .attr("class", "disease-line")
        .merge(lines)
        .attr("fill", "none")
        .attr("stroke-width", 1.6)
        .attr("stroke-opacity", 0.9)
        .attr("stroke", d => color(d.name))
        .attr("d", d => lineGen(d.values));

      lines.exit().remove();

      var overlays = gLine.selectAll(".hover-line")
        .data(yearly, d => d.name);

      overlays.enter().append("path")
        .attr("class", "hover-line")
        .merge(overlays)
        .attr("fill", "none")
        .attr("stroke", "transparent")
        .attr("stroke-width", 15)
        .attr("d", d => lineGen(d.values))
        .on("mousemove", function(d) {
          const [mx] = d3.mouse(this);
          const xDate = xLine.invert(mx);
          const year = xDate.getFullYear();
          const nearest = d.values.reduce((a, b) =>
            Math.abs(a.year - year) < Math.abs(b.year - year) ? a : b
          );
          tooltip.transition().duration(50).style("opacity", 0.9);
          tooltip.html(
            `<b>${d.name}</b><br>` +
            `${nearest.year}: ${nearest.rate.toFixed(1)} per 100,000<br>` +
            `Deaths: ${nearest.deaths.toLocaleString()}`
          )
            .style("left", (d3.event.pageX + 10) + "px")
            .style("top", (d3.event.pageY - 28) + "px");
        })
        .on("mouseout", function() {
          tooltip.transition().duration(150).style("opacity", 0);
        });

      overlays.exit().remove();

      var points = gLine.selectAll(".point")
        .data(
          yearly.flatMap(s =>
            s.values.map(v => ({ ...v, name: s.name }))
          ),
          d => d.name + "_" + d.year
        );

      points.exit().remove();

      points = points.enter()
        .append("circle")
        .attr("class", "point")
        .attr("r", 3)
        .attr("fill", d => color(d.name))
        .attr("fill-opacity", 0.9)
        .merge(points);

      points
        .attr("cx", d => xLine(new Date(d.year, 0, 1)))
        .attr("cy", d => yLine(d.rate))
        .on("mouseover", function(d) {
          d3.select(this)
            .transition().duration(80)
            .attr("r", 6);

          tooltip.transition().duration(50).style("opacity", 0.9);
          tooltip.html(
            `<b>${d.name}</b><br>` +
            `${d.year}: ${d.rate.toFixed(1)} per 100,000<br>` +
            `Deaths: ${d.deaths.toLocaleString()}`
          )
            .style("left", (d3.event.pageX + 10) + "px")
            .style("top", (d3.event.pageY - 28) + "px");
        })
        .on("mouseout", function() {
          d3.select(this)
            .transition().duration(80)
            .attr("r", 3);

          tooltip.transition().duration(150).style("opacity", 0);
        });
    }

    d3.select("#state").on("change", function() {
      updateChart(this.value);
    });

    // --- Aggregate mortality counts by state/month for mini bar chart ---
    var byKey = new Map();

    function addCount(monthCode, stateName, kind, val) {
      if (!byKey.has(monthCode)) byKey.set(monthCode, new Map());
      var m = byKey.get(monthCode);
      if (!m.has(stateName)) m.set(stateName, { asthma: 0, copd: 0, ihd: 0 });
      m.get(stateName)[kind] += val;
    }

    Promise.all([
      d3.json('./data/us-states.json'),
      d3.csv('./data/asthma_final.csv', d => addCount(d['Month Code'], d['Residence State'], 'asthma', +d['Deaths'] || 0)),
      d3.csv('./data/copd_final.csv',   d => addCount(d['Month Code'], d['Residence State'], 'copd',   +d['Deaths'] || 0)),
      d3.csv('./data/ihd_final.csv',    d => addCount(d['Month Code'], d['Residence State'], 'ihd',    +d['Deaths'] || 0))
    ]).then(([geo]) => {
      var states = geo.features;
      gMap.selectAll('path.state')
        .on('mouseover', function(d) {
          renderMiniChart(d.properties.name);
          showPop();
          movePop(d3.event);
        })
        .on('mousemove', function() { movePop(d3.event); })
        .on('mouseout', hidePop);
    });

    function renderMiniChart(stateName) {
      var selectedYear = d3.select('#year').property('value');
      var selectedPollutant = d3.select('#pollutant').property('value');

      // pollutant info box
      var pollutantInfo = d3.select('#pollutant-info');

      if (!selectedYear) {
        popSvg.selectAll('*').remove();
        popTitle.textContent = stateName;
        popSub.textContent = "Select a year to view data";
        pollutantInfo.style('display', 'none').text('');
        return;
      }

      var monthIdx = 0; // always JAN for now
      var key = keyFor(selectedYear, monthIdx);

      var pollutantConfig = {
        pm25: { name: 'PMâ‚‚.â‚…', unit: 'Î¼g/mÂ³', dataKey: 'pm25' },
        no2: { name: 'NOâ‚‚', unit: 'ppb',     dataKey: 'no2' },
        o3:  { name: 'Oâ‚ƒ',  unit: 'ppb',     dataKey: 'o3' }
      };

      if (selectedPollutant && pollutantConfig[selectedPollutant]) {
        var config = pollutantConfig[selectedPollutant];
        var monthData = pollutantData[config.dataKey].get(key);
        var pollutantValue = monthData ? (monthData.get(stateName) || 0) : 0;
        var displayVal = (pollutantValue === 0)
          ? 'Not Available'
          : pollutantValue.toFixed(2) + ' ' + config.unit;

        pollutantInfo
          .style('display', 'block')
          .text(config.name + ': ' + displayVal);
      } else {
        pollutantInfo.style('display', 'none').text('');
      }

      var rec = (byKey.get(key) || new Map()).get(stateName) || { asthma: 0, copd: 0, ihd: 0 };

      popTitle.textContent = stateName;
      popSub.textContent = `Jan ${selectedYear}`;

      var dataBars = [
        { label: 'Asthma', cls: 'asthma', value: rec.asthma },
        { label: 'COPD',   cls: 'copd',   value: rec.copd },
        { label: 'IHD',    cls: 'ihd',    value: rec.ihd }
      ];

      var W = 240, H = 150, m = { top: 6, right: 8, bottom: 28, left: 36 };
      var iw = W - m.left - m.right, ih = H - m.top - m.bottom;

      popSvg.selectAll('*').remove();
      var g = popSvg.append('g').attr('transform', `translate(${m.left},${m.top})`);

      var x = d3.scaleBand().domain(dataBars.map(d => d.label)).range([0, iw]).padding(0.35);
      var y = d3.scaleLinear()
              .domain([0, (d3.max(dataBars, d => d.value) || 1) * 1.1])
              .range([ih, 0]);

      g.append('g')
        .attr('class', 'axis axis--x')
        .attr('transform', `translate(0,${ih})`)
        .call(d3.axisBottom(x).tickSize(0));
      g.selectAll('.axis--x text')
        .attr('dy', '1.6em');

      g.append('g')
        .attr('class', 'axis axis--y')
        .call(d3.axisLeft(y).ticks(4).tickSize(-iw));

      g.selectAll('rect.bar')
        .data(dataBars)
        .enter().append('rect')
        .attr('class', d => 'bar ' + d.cls)
        .attr('x', d => x(d.label))
        .attr('y', d => y(d.value))
        .attr('width', x.bandwidth())
        .attr('height', d => ih - y(d.value))
        .attr('fill', d => color(d.label))
        .attr('fill-opacity', 0.9)
        .attr('rx', 3);

      g.selectAll('text.value')
        .data(dataBars)
        .enter().append('text')
        .attr('class', 'value')
        .attr('x', d => x(d.label) + x.bandwidth() / 2)
        .attr('y', d => y(d.value) - 6)
        .attr('text-anchor', 'middle')
        .style('font-size', '11px')
        .style('font-weight', '500')
        .style('fill', '#000000')
        .text(d => d.value.toLocaleString());
    }
  });
})();
</script>
</body>
</html>
